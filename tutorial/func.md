---
date: 2020-10-26T08:28:51+08:00  # 创建日期
author: "Rustle Karl"  # 作者

# 文章
title: "C++ 函数"  # 文章标题
url:  "posts/cpp/tutorial/func"  # 设置网页永久链接
tags: [ "cpp" ]  # 标签
series: [ "C/C++ 学习笔记"]  # 文章主题/文章系列
categories: [ "学习笔记"]  # 文章分类

# 章节
weight: 20 # 排序优先级
chapter: false  # 设置为章节

index: true  # 是否可以被索引
toc: true  # 是否自动生成目录
draft: false  # 草稿
---

- [函数原型](#函数原型)
- [函数参数的传递](#函数参数的传递)
- [传值参数](#传值参数)
  - [值传递机制](#值传递机制)
  - [实际参数求值的副作用](#实际参数求值的副作用)
  - [默认参数](#默认参数)
  - [默认参数规定](#默认参数规定)
- [指针参数](#指针参数)
- [引用参数](#引用参数)
- [函数的返回类型](#函数的返回类型)
  - [返回基本类型](#返回基本类型)
  - [返回指针类型](#返回指针类型)
  - [返回引用类型](#返回引用类型)
- [函数调用机制](#函数调用机制)
- [内联函数和重载函数](#内联函数和重载函数)
  - [内联函数](#内联函数)
  - [重载函数](#重载函数)
- [变量存储特性与标识符作用域](#变量存储特性与标识符作用域)
  - [存储特性](#存储特性)
    - [自动存储](#自动存储)
    - [静态存储](#静态存储)
  - [标识符的作用域与可见性](#标识符的作用域与可见性)
    - [函数原型作用域](#函数原型作用域)
    - [块作用域](#块作用域)
    - [函数作用域](#函数作用域)
    - [文件作用域](#文件作用域)
    - [全局变量和局部变量](#全局变量和局部变量)
- [多文件程序结构](#多文件程序结构)
  - [多文件结构](#多文件结构)
  - [预处理指令](#预处理指令)
    - [文件包含](#文件包含)
    - [宏定义指令](#宏定义指令)
    - [条件编译](#条件编译)
  - [多文件程序使用全局变量](#多文件程序使用全局变量)

## 函数原型

函数原型是函数的声明，作用是告诉编译器有关函数接口的信息：函数的名字、函数返回值的数据类型、函数的参数个数、参数类型和参数的顺序，编译器根据函数原型检查函数调用的正确性。

```c++
void count(int x, int y);
```

函数原型是一个声明语句，由函数首部加上分号组成。由于函数原型没有实现代码，因此不需要参数名。通常添加参数名是为了增加可读性，但编译器将忽略这些名称。

标准库函数的函数原型存放在指定的头文件中，用 include 预处理指令获取。

## 函数参数的传递

参数是调用函数与被调用函数之间交换数据的通道。函数定义首部的参数称为形式参数（简称形参），调用函数时使用的参数称为实际参数（实参）。

实际参数必须与形式参数在类型、个数、位置上相对应。函数被调用前，形参没有存储空间。函数被调用时，系统建立与实参对应的形参存储空间，函数通过形参与实参进行通信、完成操作。函数执行完毕，系统收回形参的临时存储空间。这个过程称为参数传递或参数的虚实结合。

C++ 语言有三种参数传递机制：值传递（值调用）、指针传递（地址调用）和引用传递（引用调用）。实际参数和形式参数按照不同传递机制进行通信。

## 传值参数

### 值传递机制

在值传递机制中，作为实际参数的表达式的值被复制到由对应的形式参名所标识的对象中，成为形参的初始值。完成参数值传递之后，函数体中的语句对形参的访问、修改都是在这个标识对象上操作的，与实际参数对象无关。

```c++
#include <iostream>

using namespace std;

void count(int x, int y) {
    x *= 2;
    y *= y;
    cout << "x=" << x << '\t';
    cout << "y=" << y << endl;
}

int main() {
    int x = 3, y = 4;
    count(x, y);
    cout << "x=" << x << '\t';
    cout << "y=" << y << endl;
}
```

如果函数具有返回值，则在函数执行 return 语句时，系统将创建一个匿名对象临时存放函数的返回结果。这个匿名对象在返回调用之后撤销。

```c++
#include <iostream>

using namespace std;

double volume(double radius, double height) {
    // 创建一个匿名对象临时存放函数的返回结果
    return 3.14 * radius * radius * height;
}

int main() {
    double vol, r, h;
    cout << "Input radius and height: \n";
    cin >> r >> h;
    vol = volume(r, h);
    cout << "Volume = " << vol << endl;
}
```

因为在传值方式中，实际参数对形式参数进行赋值操作，所以实际参数可以是各种能够对形式参数标识对象赋值的表达式。如果实参值的类型和形参对象类型不相同，将按形参的类型进行强制类型转换，然后赋给形参。

```c++
#include <iostream>

using namespace std;

double max(double x, double y, double z) {
    y = x > y ? x : y;
    return y > z ? y : z;
}

int main() {
    double x, y, z, s;
    cout << "Input x, y, z: \n";
    cin >> x >> y >> z;
    s = max(x, y, z) / (max(x + y, y, z) * max(x, y, y + z));
    cout << "s = " << s << endl;
}
```

### 实际参数求值的副作用

C++ 没有规定在函数调用时实际参数的求值顺序。实际参数求值顺序的不同规定，对一般参数没有什么影响，但若实际参数表达式之间有求值关联，则同一个程序在不同编译器可能产生不同的运行结果。

```c++
#include <iostream>

using namespace std;

int add(int a, int b) {
    return a + b;
}

int main() {
    int x = 4, y = 6;
    cout << add(++x, x + y) << endl;
}
```

### 默认参数

函数传值调用时，实际参数作为右值表达式向形式参数提供初始值。C++ 允许指定参数的默认值，当函数调用中省略默认参数时，默认值自动传递给被调用函数。

调用带参数默认值的函数时，如果显式指定实际参数值，则不使用函数参数的默认值。

```c++
#include <iostream>
#include <cmath>

using namespace std;

// 在函数原型中指定默认参数值
double dist(double, double, double = 0, double = 0);

double dist(double x1, double y1, double x2, double y2) {
    return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));
}

int main() {
    double x1, y1, x2, y2;
    cout << "Enter point (x1, y1):";
    cin >> x1 >> y1;
    cout << "Enter point (x2, y2):";
    cin >> x2 >> y2;

    cout << dist(x1, y1, x2, y2) << endl;
    cout << dist(x1, y1) << endl;
    cout << dist(x1, y1, x2) << endl;
}
```

### 默认参数规定

- C++ 规定，函数的形式参数说明中设置一个或多个实际参数的默认值，默认参数必须是函数参数表中最右边（尾部）的参数。调用具有多个默认参数的函数时，如果省略的参数不是参数表中最右边的参数，则该参数右边的所有参数也应该省略。
- 默认参数应该在函数名第一次出现时指定，通常在函数原型中。若已在函数原型中指定默认参数，则函数定义时不能重复给出。
- 默认值可以是常量、全局变量或函数调用，但不能是局部量。
- 默认参数可以用于内联函数。

## 指针参数

函数定义中的形式参数被说明为指针类型时，称为指针参数。形参指针对应的实际参数是地址表达式。调用函数时，实际参数把对象的地址值赋给形式参数名标识的指针变量，被调用函数可以在函数体内通过形参指针来间接访问实参地址所指的对象。这种参数传递方式称为指针传递或地址调用。

通过函数及其指针参数来实现两个整型变量的值交换：

```c++
#include <iostream>

using namespace std;

void swap(int *, int *);

void swap(int *x, int *y) {
    int z = *x;
    *x = *y;
    *y = z;
}

int main() {
    int a = 3, b = 8;
    cout << "before swapping:\n";
    cout << "a = " << a << ", b = " << b << endl;
    swap(&a, &b);
    cout << "after swapping:\n";
    cout << "a = " << a << ", b = " << b << endl;
}
```

形参指针可以通过获取对象地址来访问实参地址所指对象。指针参数的本质也是传值参数。对于一般传值参数，实际参数向形式参数传送的是数据表达式。而指针参数对应的实际参数是地址表达式，如果这个表达式是一个实际对象的地址值，则形式参数接收这个地址值后，可以间接访问这个地址所指的对象。

为了避免被调用函数对实参所指对象的修改，可以用关键字 const 约束形参指针的访问特性。

```c++
#include <iostream>

using namespace std;

int func(const int *const p) {
    int a = 10;
    a += *p;
    //*p=a;
    //p=&a;
    return a;
}

int main() {
    int x = 10;
    cout << func(&x) << endl;
}
```

实参表达式是变量 x 的地址，形参 p 被定义为指向常量的常指针。调用函数时，用实参地址值初始化后，函数体对 p 和 *p 的访问都被约束为只读，从而保护了实参 x 不能通过 p 修改。

可以不约束 p 的访问：

```c++
int func(const int *p);

p = a; // 合法
```

但这一来，形参指针 p 就与实参所指对象失去关联了。

当将常对象的地址传递给形参指针时，形参必须用 const 约束。

```c++
#include <iostream>

using namespace std;

int func(const int *p) {
    int a = 10;
    a += *p;
    return a;
}

int main() {
    const int M = 10;
    cout << func(&M) << endl;
}
```

## 引用参数

如果 C++ 函数的形式参数被定义为引用类型，则称为引用参数。引用参数对应的实际参数应该是对象名。函数被调用时，形式参数不需要开辟新的存储空间，形式参数名作为引用（别名）绑定于实际参数标识的对象上。执行函数体时，对形参的操作就是对实参对象操作。直到函数执行结束，撤销引用绑定。

通过函数及其引用参数来实现两个整型变量的值交换：

```c++
#include <iostream>

using namespace std;

void swap(int &, int &);

void swap(int &x, int &y) {
    int z = x;
    x = y;
    y = z;
}

int main() {
    int a = 3, b = 8;
    cout << "before swapping:\n";
    cout << "a = " << a << ", b = " << b << endl;
    swap(a, b);
    cout << "after swapping:\n";
    cout << "a = " << a << ", b = " << b << endl;
}
```

调用函数 swap 后，形参 x、y 分别是实参 a、b 的引用，函数体内对 x、y 的操作实际上是对 a、b 的操作。

引用参数和指针参数都不需要像传值参数那样产生实参对象数据的副本，并且，引用参数不像指针参数那样通过间址访问实参对象，特别适用于大对象参数的高效操作。

和指针参数的情形一样，为了避免被调用函数对实参对象产生不必要的修改，可以使用 const 限定引用。

```c++
void swap(const int &, int &);
```

## 函数的返回类型

C++ 函数可以通过指针参数或引用参数修改实际参数，从而获取函数的运行结果。return 语句也可以返回表达式的执行结果。

### 返回基本类型

如果函数定义的返回类型为基本数值类型，则执行return语句时，首先计算表达式的值，然后把该值赋给 C++ 定义的匿名对象。匿名对象的类型是函数定义的返回类型。通过这个匿名对象，把数值带回函数的调用点，继续执行后续代码。

对匿名对象赋值时，如果表达式的值的类型与函数定义的返回类型不相同，将强制转换成函数的返回类型。

### 返回指针类型

函数被调用之后可以返回一个对象的指针值（地址表达式）。返回指针类型值的函数称为指针函数。

```c++
#include <iostream>

using namespace std;

int *max(int *x, int *y) {
    return *x > *y ? x : y;
}

int main() {
    int x, y;
    cout << "Input x, y:";
    cin >> x >> y;
    cout << *max(&x, &y) << endl;
}
```

指针函数不能返回局部量的指针，比如函数内部建立的临时对象。

### 返回引用类型

C++ 函数返回对象引用时，不产生返回实际对象的副本，返回时的匿名对象是实际返回对象的引用。返回引用比返回指针更直接，可读性更好。

```c++
#include <iostream>

using namespace std;

int &max(int &x, int &y) {
    return x > y ? x : y;
}

int main() {
    int x, y;
    cout << "Input x, y:";
    cin >> x >> y;
    cout << max(x, y) << endl;
}
```

函数返回引用需要依托于一个对象。显然，被依托的返回对象不能是函数体内说明的局部变量。其原因与返回指针的函数一样，被调用函数内定义的局部量是临时对象，函数返回时将被释放。

返回对象可以是非局部对象或静态对象。

函数返回引用，使得函数调用本身是对象的引用，就像返回对象的标识别名。所以，返回引用的函数调用可以作为左值。

```c++
#include <iostream>

using namespace std;

int &count(int);

int a, b;

int &count(int n) {
    return n > 0 ? a : b;
}


int main() {
    int x;
    cout << "Input numbers, the 0 is end: \n";
    cin >> x;
    while (x) {
        count(x)++;
        cin >> x;
    }
    cout << "the number of right: " << a << endl;
    cout << "the number of negative: " << b << endl;
}
```

## 函数调用机制

## 内联函数和重载函数

内联函数是C++语言为降低小程序调用开销而采取的一种机制。

函数重载是指以同一个名字命名多个函数实现版本。重载函数是一种简单的多态形式。

### 内联函数

函数调用时，需要建立栈空间来保存调用时的现场状态和返回地址，并且进行参数传送，产生程序转移。系统完成这些工作都需要时间和空间方面的开销。因此，C++ 提供内联函数机制，定义一些功能比较简单、代码比较短的函数。编译时，系统把内联函数的函数体嵌入到每一个函数调用处，节省了程序运行时的调用开销。

定义内联函数的方法是，在函数名第一次出现时，在函数名之前冠以关键字 inline。通常在函数原型中指定。若已在函数原型中指定 inline，则函数定义时不能重复给出。

从键盘输入一串字符，以回车结束，统计其中数字字符个数。

```c++
#include <iostream>

using namespace std;

inline int isNumber(char);

int isNumber(char ch) {
    return (ch >= '0' && ch <= '9') ? 1 : 0;
}

int main() {
    char c;
    int n;
    n = 0;
    while ((c = getchar()) != '\n')
        if (isNumber(c)) n++;
    cout << "n = " << n << endl;
}
```

- 若inline不在函数名第一次出现时指定，则编译器把它作为普通函数处理。
- 一般内联函数只适合于 1 ～ 5 行的小程序。在内联函数中，不能含有复杂的流程控制语句。例如，不能含有多分支语句和循环语句，否则，inline 无效。
- 递归函数不能说明为内联函数。

### 重载函数

C++ 语言允许定义多个同名函数，各个函数有不同的参数集，这些函数称为重载函数。编译器根据不同参数的类型和个数产生调用匹配。函数重载常用于生成几个类似任务而处理不同数据个数、类型的同名函数。

```c++
#include <iostream>

using namespace std;

int max(int, int);

int max(int, int, int);

int max(int x, int y) {
    return x > y ? x : y;
}

int max(int x, int y, int z) {
    return max(max(x, y), z);
}

int main() {
    cout << max(5, 3) << endl;
    cout << max(4, 6, 9) << endl;
}
```

C++ 编译器只根据函数参数表（参数类型和个数）进行重载版本的调用匹配，函数返回值的内容不起作用。

```c++
int average(int, int);
double average(int, int);
```

这两个不是重载函数，C++ 编译器认为是函数重复说明。

重载函数中使用默认参数时可能产生的二义性。

## 变量存储特性与标识符作用域

标识符存储特性确定了标识符在内存中的生存时间和连接特性。

标识符作用域是指在程序正文中能够引用这个标识符的那部分区域。

如果一个标识符在作用域的某部分程序正文区域中能够被直接引用，则称标识符在这个区域中可见。

C++ 的一个应用程序称为一个项目。一个项目可以由多个文件组成。标识符的连接特性决定标识符能否被工程中的其他文件引用。

### 存储特性

C++ 有两类存储特性：自动存储和静态存储。

#### 自动存储

自动存储用关键字 auto 和 register 说明。只有变量具有自动存储特性。这种变量在进入说明的块时生成，在结束块时删除。

```c++
auto double x, y;
```

显式地说明变量 x、y 为自动变量。

函数的参数和局部变量都是自动存储的。C++ 把变量默认为自动存储，所以关键字 auto 很少用。

关键字 register 说明把变量存放在寄存器中。如今，C++ 的优化编译器能够识别经常使用的变量，决定是否存放在寄存器中，而不需要程序员进行 register 说明。

由此可见，自动存储是变量的默认状态。

#### 静态存储

关键字 extern 和 static 说明静态存储变量和函数标识符。全局说明的标识符默认为 extern。

如果这两个关键字用于说明变量，程序在开始执行时就分配和初始化存储空间；如果用于说明函数，表示从程序执行开始就存在这个函数名。

尽管标识符被说明为静态时，程序一开始执行就存在，但不等于它们在整个程序中可用。用 static 说明的局部变量只能在定义该变量的函数体中使用。与自动变量不同的是，static 在第一次使用时进行初始化（默认初始化值为 0 ）。函数退出时，系统保持其存储空间和数值。下次调用这个函数时，static 变量还是上次退出函数时的值。

```c++
#include <iostream>

using namespace std;

int func();

int func() {
    int a = 1;
    static int b = 1;
    a++;
    b++;
    cout << "auto a=" << a << endl;
    cout << "static b=" << b << endl;
    return a + b;
}

int main() {
    cout << func() << endl;
    cout << func() << endl;
    cout << func() << endl;
}
```

### 标识符的作用域与可见性

程序中常用的标识符有变量、常量、函数、类型等命名符。作用域是指一个已说明的标识符在程序正文中有效的那部分区域。若一个标识符在某部分程序正文能够被直接引用，则称这个标识符在这部分程序正文内可见。在一般情况下，一个标识符在作用域内可见，但在嵌套或层次结构程序模块中，如果定义了同名标识符，它们的可见性和作用域就不一定等价。

C++ 的标识符有 5 种作用域：函数原型、块、函数、类和文件作用域。

#### 函数原型作用域

只有函数原型形式参数表中使用的标识符才具有函数原型作用域。因为函数原型是一个独立的声明语句，形式参数名不需要使用，所以，函数原型不要求参数表中使用标识符名称，只要求类型。如果函数原型参数表中使用名称，将被编译器忽略。

#### 块作用域

块是指在函数定义中由一对花括号相括的一段程序单元。一个程序块内允许嵌套另外一个块。在块中说明的标识符具有块作用域，其作用域从说明点开始，直到结束块的右花括号处为止。

#### 函数作用域

语句标号（后面带冒号的标识符）是唯一具有函数作用域的标识符。语句标号一般用于 switch 结构中的 case 标号，以及 goto 语句转向入口的语句标号。标号可以在函数体中任何地方使用，但不能在函数体外引用。

实际上，函数体是一个特殊的语句块。

#### 文件作用域

任何在函数之外说明的标识符都具有文件作用域。这种标识符从说明处起至文件尾的任何函数都可见。

#### 全局变量和局部变量

具有文件作用域的变量称为全局变量，具有块作用域的变量称为局部变量。全局变量说明时默认初始值为 0。当局部量与全局量同名时，在块内，全局量被屏蔽。

可以用作用域运算符 `::` 访问全局变量。

```c++
#include <iostream>

using namespace std;

int x;

int main() {
    int x = 256;
    cout << "global variable x = " << ::x << endl;
    cout << "local variable x = " << x << endl;
}
```

在主函数模块内，局部变量 x 屏蔽了全局变量 x，但不是覆盖，虽然全局变量 x 不可见（不能直接引用），但依然有作用，所以可以用作用域符指定访问。全局量的作用域不会因为同名局部量而被覆盖。而外层块与内层块有同名变量时，在内层块不能通过作用域符访问外层块的同名变量。这是块作用域变量与全局变量不同的地方。

内层块可以说明与外层块同名的变量，函数可以通过非局部量返回运算结果。但将变量说明为全局量可能会发生意想不到的副作用。有时，不需要访问该变量的函数可能会意外地修改了它，产生难以查找的错误。除非有特殊的要求，否则，程序中一般不应该使用全局变量。**当函数的数据传输只使用参数而不需要全局变量时，我们称这个函数是低耦合度的。**低耦合度的程序模块便于调试、便于重用。

## 多文件程序结构

一个 C++ 程序称为一个项目。一个项目由一个或多个文件组成。文件结构便于程序按逻辑功能划分，便于程序测试。

一个文件可以包含多个函数定义，但一个函数的定义必须完整地存在于一个文件中。

### 多文件结构

扩展名为“.h”的头文件和扩展名为“.cpp”源程序文件。

一个能够表达特定程序功能的模块由两部分构成：规范说明和实现部分。规范说明描述一个模块与其他模块的接口，一般包括：函数原型、类说明、类型说明、全局量说明、包含指令、宏定义、注释等。规范说明通常集中在头文件，各模块通过头文件的接口产生引用。实现部分则放在.cpp文件中，通常称为实现文件。

### 预处理指令

C++ 语言中，不论是 .h 文件还是 .cpp 文件，都是可以阅读的文本文件。要把它们翻译成可执行文件，主要经过三个步骤：预处理、编译和连接。

预处理器的功能是，阅读源程序，执行预处理指令，嵌入指定源文件。预处理器生成新的临时文件，提供给编译器进行语法分析、语义分析，生成目标代码。最后，连接器连接标准库，生成可执行文件。

预处理指令不是 C++ 的语句，但它们可以改善程序的组织和管理，是程序员常用的工具。预处理指令以“#”号开始，每一条指令独占一行。预处理指令可以根据需要出现在程序的任何位置。

#### 文件包含

`#include` 指令实现文件包含，在编译之前把指定文件的文本抄到该命令所在位置，用于支持多文件形式组织的 C++ 程序。

其中，include 为关键字。文件名是被包含文件的全名，按操作系统的要求定义，可以给定盘符和目录路径。

第一种形式用尖括号相括文件名，用于 C++ 提供的系统标准头文件。这些文件存放在 C++ 系统目录中的 include 子目录下。C++ 编译器识别这条指令后，直接从 include 子目录中查找尖括号相括的文件，嵌入指令所在的文件。

使用 C++ 的标准头文件还需指定名空间或对特定组件指定所属的名空间。

第二种形式用双引号相括文件名，一般用于包含程序员自己建立的头文件。C++ 编译器识别这条指令后，首先搜索当前子目录，如果没有找到，再去搜索 C++ 的系统子目录。自定义头文件需要用 .h 作为扩展名。

文件包含指令一般放在程序的开头。

#### 宏定义指令

宏定义指令 `#define` 用来指定正文替换程序中出现的标识符。

在C语言中，不带参数 `#define` 常用于定义常量，带参数 `#define` 用于定义简单函数。

由于宏指令是在程序正式编译之前执行的，所以不能对替换内容进行语法检查。C++ 的关键字 const 定义常量和 inline 定义的内联函数代替了`#define` 定义常量和函数的作用。

#### 条件编译

条件编译指令可以根据一个常量值作为判断条件，决定源程序中某一段代码是否参加编译。条件编译指令的结构与 if 选择结构非常相似。

```c++
#if 常量表达式
代码
#endif
```

```c++
#if 常量表达式
代码
#else
代码
#endif
```

条件编译指令中的“常量表达式”必须在编译时（程序执行之前）就有确定值。不能在“常量表达式”中进行强制类型转换，或作 sizeof 计算，也不能是枚举常量。

```c++
#ifndef 标识符
    #define 标识符
    代码
    #endif
```

若“标识符”没有定义，则“程序文本”被编译；若“标识符”已经定义，则“程序文本”被忽略。

为避免多文件结构的重定义错误，除了在头文件中使用条件编译指令外，还应该尽量做到声明和定义分离，在头文件中只写数据类型、函数原型声明，把变量的定义和函数定义放在cpp文件中，养成良好的程序书写习惯。

### 多文件程序使用全局变量

在所有函数之外定义的全局变量在默认情况下具有静态存储特性。全局变量可以被同一个文件中该变量说明之后的所有函数访问。程序的其他文件也能够访问全局变量，但必须在使用该全局变量的每一个文件中用关键字 extern 予以声明。

存储说明符 extern 告诉编译器，变量 global 或者在同一个文件中稍后定义，或者在另一个文件中定义。编译器会通知连接程序，查找 global 的说明位置，从而解决对该变量的引用。

因为全局量可以被所有函数访问，所以使用全局量会降低函数之间传递数据的开销。但这样做违背了程序结构化和信息隐蔽的原则。若不是应用程序的执行效率至关重要的情况，不应该使用全局变量。

函数原型默认为 extern，即一个文件中只要声明了函数原型，函数定义就可以放在同一个文件或另外的文件中。例如，用 include 指令把函数原型嵌入当前文件之后，程序员就不需去关心函数定义的位置了。

如果希望全局变量或函数的作用范围限制在定义它的文件中，可以使用存储说明符 static。

```c++

```

```c++

```


```c++

```

```c++

```

```c++

```


```c++

```



```c++

```

```c++

```


```c++

```



```c++

```

```c++

```


```c++

```




